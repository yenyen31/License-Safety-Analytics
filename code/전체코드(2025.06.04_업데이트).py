# -*- coding: utf-8 -*-
"""코드.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jCqO6yK8LYRpiwVDvAOAO2m-KA8kULfR

# **운전면허 보급과 교통안전 상관분석**

> 빅데이터분석_기말프로젝트_이예은

# 개발 환경 세팅

구글 드라이브 마운트
"""

from google.colab import drive
drive.mount('/content/drive')

"""라이브러리 설치"""

!pip install pandas requests scikit-learn matplotlib seaborn geopandas lightgbm shap

import pandas as pd
import os

from google.colab import drive
from IPython.display import display

# 시각화
import matplotlib.pyplot as plt
import matplotlib as mpl

import numpy as np
import seaborn as sns

# 한글 폰트 설치 & 적용
!apt-get update -qq
!apt-get install fonts-nanum -qq

from matplotlib import font_manager

# 나눔고딕 폰트 경로 찾기
font_path = '/usr/share/fonts/truetype/nanum/NanumGothic.ttf'
font_manager.fontManager.addfont(font_path)
mpl.rc('font', family='NanumGothic')
mpl.rc('axes', unicode_minus=False)  # 음수 기호 깨짐 방지

"""프로젝트 폴더 구조
- data/raw/ → 원본 CSV/XML/API에서 받은 데이터
- data/clean/ → 정제한(결측·이상치 처리한) 데이터
- notebooks/ → Jupyter 노트북(EDA·모델링)
- scripts/ → 수집·전처리 파이썬 스크립트

# 데이터셋 불러오기
: 각 파일을 pd.read_excel로 DataFrame으로 로드

> - 운전면허소지자 현황 : license.xlsx
- 자치구별 인구수(연령대) : population.xlsx
- 교통사고현황(사고유형별) : accident.xlsx
- 자치구별 인구밀도 : population_density.xlsx
- 자치구별 1인당 지역내총생산 및 수준지수 : per_capita_GDP.xlsx
- 자동차등록현황보고 : car_registration.xlsx
"""

# 자치구별 면허 데이터 불러오기
license_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/license.xlsx')

# 자치구별 인구 통계
population_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/population.xlsx')

# 자치구별 교통사고 통계
accident_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/accident.xlsx')

# 자치구별 인구 밀도
population_density_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/population_density.xlsx')

# 자치구별 1인당 지역내총생산 및 수준지수
GDP_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/GDP.xlsx')

# 자동차 등록 현황 보고
car_registration_df = pd.read_excel('/content/drive/MyDrive/License_Safety_Project/data/clean/car_registration.xlsx')

"""# 데이터 전처리
- 컬럼명 표준화 : 모든 DataFrame에서 ‘지역코드’ 칼럼을 ‘region_code’로 통일

기본 구조 점검
- df.shape로 행·열 개수 확인
- df.columns.tolist()로 컬럼명을 리스트로 확보
- df.head() / df.info() / df.describe() 로 주요 값·타입·통계 요약 확인

컬럼 목록 추출
- 각 DataFrame의 columns.tolist() 결과를 모아 데이터별 컬럼 구성을 파악

면허 데이터 전처리 - license
"""

# 2) Standardize the column name
license_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# '지역', 'region_code' 제외한 나머지 수치 컬럼만 int로 변환
acc_cols = [c for c in accident_df.columns if c not in ['지역','region_code']]
for col in acc_cols:
    accident_df[col] = (
        pd.to_numeric(accident_df[col].astype(str).str.replace(',',''), errors='coerce')
          .fillna(0)
          .astype(int)
    )

# 3) Quick checks
print("Shape:", license_df.shape)
print("\nColumns:", license_df.columns.tolist())

# 4) Preview and summary
from IPython.display import display
display(license_df.head())
license_df.info()
display(license_df.describe())

license_agg = (
    license_df
    .groupby('region_code')[['1종소계','2종소계','2종 원자']]
    .sum()
    .reset_index()
)
license_agg['license_total'] = (
    license_agg['1종소계'] +
    license_agg['2종소계'] +
    license_agg['2종 원자']
)

"""교통 사고 데이터 정보 전처리 - accident"""

# 2) Standardize the column name
accident_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# 3) 나머지 컬럼을 숫자형으로 변환
num_cols = [c for c in accident_df.columns if c != 'region_code']
for col in num_cols:
    accident_df[col] = (
        pd.to_numeric(accident_df[col].astype(str).str.replace(',', ''), errors='coerce')
          .fillna(0)
          .astype(int)
    )

# 3) Quick checks
print("Shape:", accident_df.shape)
print("\nColumns:", accident_df.columns.tolist())

# 4) Preview and summary
from IPython.display import display
display(accident_df.head())
accident_df.info()
display(accident_df.describe())

# 전처리된 accident_df 기준으로 acc_agg 정의
# num_cols 는 'region_code'를 제외한 수치형 컬럼 리스트
num_cols = [c for c in accident_df.columns if c != 'region_code']

acc_agg = (
    accident_df
      .groupby('region_code')['합계']
      .sum()
      .reset_index()
      .rename(columns={'합계':'accidents'})
)

# 결과 확인
print(acc_agg.head())

"""자치구별 인구수 데이터 전처리 - population"""

# 2) Standardize the column name
population_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# region_code랑 '행정기관' 제외하고 숫자형으로 변환
pop_cols = [c for c in population_df.columns if c not in ['region_code','행정기관']]
for col in pop_cols:
    population_df[col] = (
        pd.to_numeric(population_df[col].astype(str).str.replace(',',''), errors='coerce')
          .fillna(0)
          .astype(int)
    )

# 3) Quick checks
print("Shape:", population_df.shape)
print("\nColumns:", population_df.columns.tolist())

# 4) Preview and summary
display(population_df.head())
population_df.info()
display(population_df.describe(include='all'))

"""자치구별 인구 밀도 데이터 전처리 - population_density"""

# 2) Standardize the column name
population_density_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# Convert all other columns to int
for col in population_df.columns:
    if col != 'region_code':
        population_df[col] = (
            pd.to_numeric(population_df[col].astype(str).str.replace(',', ''), errors='coerce')
              .fillna(0)
              .astype(int)
        )

# 3) Quick checks
print("Shape:", population_density_df.shape)
print("Columns:", population_density_df.columns.tolist())

# 4) Preview and summary
display(population_density_df.head())
population_density_df.info()
display(population_density_df.describe())

"""1인당, 자치구별 GDP 데이터 전처리 - GDP"""

# 2) Standardize the column name
GDP_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# Convert all other columns (except region_code) to numeric, preserving float where needed
for col in GDP_df.columns:
    if col != 'region_code':
        GDP_df[col] = (
            pd.to_numeric(GDP_df[col].astype(str).str.replace(',', ''), errors='coerce')
              .fillna(0)
        )

# 3) Quick checks
print("Shape:", GDP_df.shape)
print("Columns:", GDP_df.columns.tolist())

# 4) Preview and summary
display(GDP_df.head())
GDP_df.info()
display(GDP_df.describe(include='all'))

"""자동차 등록 현황 데이터 전처리 - car_registration"""

# Rename '지역코드' to 'region_code'
# If there is a column for district name (e.g., '시군구' or similar), rename to 'region_name'
car_registration_df.rename(columns={'지역코드': 'region_code'}, inplace=True)

# '시군구','region_code' 제외하고 숫자형으로 변환
car_cols = [c for c in car_registration_df.columns if c not in ['시군구','region_code']]
for col in car_cols:
    car_registration_df[col] = (
        pd.to_numeric(car_registration_df[col].astype(str).str.replace(',',''), errors='coerce')
          .fillna(0)
          .astype(int)
    )

# 3) Quick checks
print("Shape:", car_registration_df.shape)
print("Columns:", car_registration_df.columns.tolist())

# 4) Preview and summary
display(car_registration_df.head())
car_registration_df.info()
display(car_registration_df.describe(include='all'))

"""# 파생 변수 생성

> - license_rate:	인구 대비 면허 보유 비율
- vehicle_rate:	인구 대비 등록 차량 수 비율
- accident_rate:	인구 대비 사고 발생률
- fatality_rate:	사고 대비 사망 비율 (치명률, 사망자수 ÷ 총 사고 건수)
- injury_rate:	사고 대비 부상 비율 (부상자수 ÷ 총 사고 건수)
- accident_per_vehicle:	차량 1대당 사고 발생률 (총 사고 건수 ÷ 총 차량 수)
- accident_per_license:	면허 1명당 사고 발생률 (총 사고 건수 ÷ 총 면허 소지자 수)
- accident_per_gdp:	총 GDP 대비 사고 건수 비율 (총 사고 건수 ÷ 총 GDP(백만원))
- gdp_per_capita:	자치구 1인당 GRDP (천원 단위)

### 파생 지표 생성을 위한 추가 전처리
"""

import numpy as np

# —————————————————————————————————————————————————————————
# (가정) 기존에 아래 변수가 이미 정의되어 있는 상태:
# license_agg, acc_agg, df_accident, population_df, population_density_df, car_registration_df, GDP_df
# —————————————————————————————————————————————————————————

# 1) 교통사고(acc_agg) 컬럼 점검
print("▶ acc_agg 컬럼:", acc_agg.columns.tolist())
# 만약 acc_agg가 다음과 같이 만들어지지 않았다면, 아래처럼 재정의 해주세요:
# acc_agg = (
#     df_accident
#     .pivot_table(
#         index='region_code',
#         columns='구분별',
#         values='2024',
#         aggfunc='sum'
#     )
#     .reset_index()
# )
# acc_agg.columns.name = None
# # “합계” → accidents
# if '합계' in acc_agg.columns:
#     acc_agg = acc_agg.rename(columns={'합계':'accidents'})
# else:
#     raise KeyError("'합계' 컬럼이 acc_agg에 없습니다.")

# # 사망자수(“사망자수 (명)”)와 부상자수(“부상자수 (명)”)가 존재하면 컬럼 이름 변경
# if '사망자수 (명)' in acc_agg.columns:
#     acc_agg = acc_agg.rename(columns={'사망자수 (명)':'deaths'})
# if '부상자수 (명)' in acc_agg.columns:
#     acc_agg = acc_agg.rename(columns={'부상자수 (명)':'injuries'})

# 2) car_registration_df 총 차량 수 생성(‘총계’ 컬럼 사용)
print("▶ car_registration_df 컬럼:", car_registration_df.columns.tolist())
if '총계' not in car_registration_df.columns:
    raise KeyError("'총계' 컬럼이 car_registration_df에 없습니다.")
car_registration_df['total_vehicles'] = car_registration_df['총계']

# 3) GDP_df 컬럼명 점검
print("▶ GDP_df 컬럼:", GDP_df.columns.tolist())
gdp_rename_map = {}
if '지역내총생산(당해년가격) (백만원)' in GDP_df.columns:
    gdp_rename_map['지역내총생산(당해년가격) (백만원)'] = 'total_gdp'
if '1인당 지역내총생산 (천원)' in GDP_df.columns:
    gdp_rename_map['1인당 지역내총생산 (천원)'] = 'gdp_per_capita'
GDP_df = GDP_df.rename(columns=gdp_rename_map)
if 'total_gdp' not in GDP_df.columns or 'gdp_per_capita' not in GDP_df.columns:
    raise KeyError("GDP_df에 'total_gdp' 또는 'gdp_per_capita' 컬럼이 없습니다.")

# 4) 자치구별 통합 DataFrame 생성
merged_df = license_agg.merge(
    acc_agg[['region_code','accidents']],
    on='region_code', how='inner'
).merge(
    population_df[['region_code','총 거주자수']],
    on='region_code', how='inner'
).merge(
    population_density_df[['region_code','인구밀도 (명/㎢)']],
    on='region_code', how='inner'
).merge(
    car_registration_df[['region_code','total_vehicles']],
    on='region_code', how='inner'
).merge(
    GDP_df[['region_code','total_gdp','gdp_per_capita']],
    on='region_code', how='inner'
)

print("\n▶ merged_df 컬럼:", merged_df.columns.tolist())
display(merged_df.head())

"""### 파생 변수 지표 생성
- 생성한 모든 파생 지표는 merged_df에 저장
"""

# 5) 파생 지표 생성
# 5-1) 면허율
merged_df['license_rate'] = merged_df['license_total'] / merged_df['총 거주자수']

# 5-2) 차량 비율
merged_df['vehicle_rate'] = merged_df['total_vehicles'] / merged_df['총 거주자수']

# 5-3) 사고율
merged_df['accident_rate'] = merged_df['accidents'] / merged_df['총 거주자수']

# 5-4) 치명률(fatality_rate)
#    acc_agg에는 deaths(사망자수) 컬럼이 없을 수 있으므로,
#    먼저 확인하고 없으면 0으로 채움
if 'deaths' in acc_agg.columns:
    merged_df = merged_df.merge(
        acc_agg[['region_code','deaths']],
        on='region_code', how='left'
    )
    merged_df['deaths'] = merged_df['deaths'].fillna(0).astype(int)
else:
    merged_df['deaths'] = 0

merged_df['fatality_rate'] = np.where(
    merged_df['accidents'] > 0,
    merged_df['deaths'] / merged_df['accidents'],
    0
)

# 5-5) 부상률(injury_rate)
#    acc_agg에 injuries(부상자수) 컬럼이 없으면 0으로 채움
if 'injuries' in acc_agg.columns:
    merged_df = merged_df.merge(
        acc_agg[['region_code','injuries']],
        on='region_code', how='left'
    )
    merged_df['injuries'] = merged_df['injuries'].fillna(0).astype(int)
else:
    merged_df['injuries'] = 0

merged_df['injury_rate'] = np.where(
    merged_df['accidents'] > 0,
    merged_df['injuries'] / merged_df['accidents'],
    0
)

# 5-6) 차량 1대당 사고 발생률
merged_df['accident_per_vehicle'] = np.where(
    merged_df['total_vehicles'] > 0,
    merged_df['accidents'] / merged_df['total_vehicles'],
    0
)

# 5-7) 면허 1명당 사고 발생률
merged_df['accident_per_license'] = np.where(
    merged_df['license_total'] > 0,
    merged_df['accidents'] / merged_df['license_total'],
    0
)

# 5-8) GDP 대비 사고 건수 비율
merged_df['accident_per_gdp'] = np.where(
    merged_df['total_gdp'] > 0,
    merged_df['accidents'] / merged_df['total_gdp'],
    0
)

# 5-9) gdp_per_capita 컬럼은 이미 존재하므로 생략

# 6) 파생지표 결과 확인
pd.set_option('display.float_format', lambda x: f"{x:.4f}")
print("\n▶ 파생 지표 예시:")
display(
    merged_df[[
        'region_code',
        'license_rate','vehicle_rate','accident_rate',
        'fatality_rate','injury_rate',
        'accident_per_vehicle','accident_per_license',
        'accident_per_gdp','gdp_per_capita'
    ]].head(10)
)

"""# 상관관계 분석

### 면허율, 사고율의 상관관계
"""

print(accident_df.columns.tolist())
print(acc_agg.head())

"""면허율, 사고율 계산"""

# 면허율, 사고율 계산
license_rates = license_agg.merge(
    population_df[['region_code','총 거주자수']], on='region_code')

license_rates['license_rate'] = license_rates['license_total'] / license_rates['총 거주자수']

accident_rates = acc_agg.merge(
    population_df[['region_code','총 거주자수']], on='region_code')

accident_rates['accident_rate'] = (
    accident_rates['accidents'] / accident_rates['총 거주자수'])

# 확인
display(license_rates.head())
display(accident_rates.head())

"""면허율과 사고율의 상관관계"""

# 1) Merge license_rates and accident_rates into a single DataFrame
rates_df = pd.merge(
    license_rates[['region_code', 'license_rate']],
    accident_rates[['region_code', 'accident_rate']],
    on='region_code'
)

# 시각화
# 2) Scatter plot: License Rate vs Accident Rate
plt.figure()
plt.scatter(rates_df['license_rate'], rates_df['accident_rate'])
plt.xlabel('License Rate')
plt.ylabel('Accident Rate')
plt.title('Relationship between License Rate and Accident Rate')
plt.tight_layout()
plt.show()

"""### GRDP과 사고율 상관관계"""

# 3) Merge accident_rates with GDP per capita
df = accident_rates.merge(
    GDP_df[['region_code', '1인당 지역내총생산 (천원)']],
    on='region_code',
    how='left'
)

# 4) Compute correlation
corr = df['accident_rate'].corr(df['1인당 지역내총생산 (천원)'])
print(f"Correlation between per-capita GRDP and accident rate: {corr:.3f}")

# 5) Scatter plot
plt.figure(figsize=(6, 4))
plt.scatter(df['1인당 지역내총생산 (천원)'], df['accident_rate'])
plt.xlabel('Per-Capita GRDP (천원)')
plt.ylabel('Accident Rate')
plt.title('Per-Capita GRDP vs Accident Rate')
plt.tight_layout()
plt.show()

"""### 자동차 등록대수와 사고율 상관관계"""

# Sum accident types by region_code
acc_pivot = (
    accident_df
    .groupby('region_code')[['차대사람', '차대차', '차량단독']]
    .sum()
    .reset_index()
)


print(acc_pivot.head())

# Sum registered vehicles by region_code
car_pivot = (
    car_registration_df
      .groupby('region_code')[['총계']]
      .sum()
      .reset_index()
      .rename(columns={'총계':'total_vehicles'})
)

print(car_pivot.head())

# Merge accident data and car registration data
df_merged = acc_pivot.merge(car_pivot, on='region_code', how='left')

# Calculate accident rate per 10,000 vehicles (example metric)
# Handle potential division by zero
df_merged['accidents_per_10k_vehicles'] = (
    (df_merged[['차대사람', '차대차', '차량단독']].sum(axis=1) /
     df_merged['total_vehicles']) * 10000
)
df_merged.replace([np.inf, -np.inf], np.nan, inplace=True) # Replace inf with NaN
df_merged.dropna(subset=['accidents_per_10k_vehicles', 'total_vehicles'], inplace=True) # Drop rows with NaN

# Compute correlation between total vehicles and accidents per 10k vehicles
corr_vehicles = df_merged['total_vehicles'].corr(df_merged['accidents_per_10k_vehicles'])
print(f"Correlation between total registered vehicles and accidents per 10k vehicles: {corr_vehicles:.3f}")

# Scatter plot
plt.figure(figsize=(8, 5))
plt.scatter(df_merged['total_vehicles'], df_merged['accidents_per_10k_vehicles'])
plt.xlabel('Total Registered Vehicles')
plt.ylabel('Accidents per 10,000 Vehicles')
plt.title('Total Vehicles vs Accidents per 10,000 Vehicles')
plt.tight_layout()
plt.show()

"""### 인구밀도와 사고율의 상관관계"""

# 사고 합계(합계 컬럼)를 지역별로 집계
acc_agg = (accident_df
           .groupby('region_code')['합계']
           .sum()
           .reset_index()
           .rename(columns={'합계':'accidents'}))

population_df['총 거주자수'] = pd.to_numeric(
    population_df['총 거주자수'].astype(str).str.replace(',',''),
    errors='coerce'
).fillna(0).astype(int)

# 사고율 계산
accident_rates = acc_agg.merge(
    population_df[['region_code','총 거주자수']],
    on='region_code'
)
accident_rates['accident_rate'] = (
    accident_rates['accidents'] / accident_rates['총 거주자수']
)

# 3) 이제 병합
df_corr = accident_rates.merge(
    population_density_df[['region_code','인구밀도 (명/㎢)']],
    on='region_code',
    how='inner'
)

# 4) 값 분포 점검
print(df_corr[['accident_rate','인구밀도 (명/㎢)']].describe())

# 5) 상관계수 계산
corr_value = df_corr['인구밀도 (명/㎢)'].corr(df_corr['accident_rate'])
print(f"Correlation: {corr_value:.3f}")

# 시각화
# Scatter plot
plt.figure(figsize=(6, 4))
plt.scatter(df_corr['인구밀도 (명/㎢)'], df_corr['accident_rate'])
plt.xlabel('Population Density (명/㎢)')
plt.ylabel('Accident Rate')
plt.title('Population Density vs Accident Rate')
plt.tight_layout()
plt.show()

"""### 사고가 많은 자치구 상위 10개 대상, 사고 유형 비율 분석"""

# 사고 유형별 분포를 위해 필요한 컬럼만 선택
accident_types_df = accident_df[['region_code', '차대사람', '차대차', '차량단독']]

# '합계' 컬럼 생성 (각 사고 유형의 합)
accident_types_df['합계'] = accident_types_df[['차대사람', '차대차', '차량단독']].sum(axis=1)

# 합계 기준으로 상위 10개 자치구 선택
top_10_districts = (
    accident_types_df
    .groupby('region_code')['합계']
    .sum()
    .sort_values(ascending=False)
    .head(10)
    .index.tolist()
)

# 상위 10개 자치구 데이터 필터링
accident_top10 = accident_types_df[accident_types_df['region_code'].isin(top_10_districts)]

# 시각화를 위해 데이터 재구성
accident_top10_melted = accident_top10.melt(
    id_vars=['region_code'],
    value_vars=['차대사람', '차대차', '차량단독'],
    var_name='사고유형',
    value_name='사고건수'
)

# 각 자치구별 사고 유형 합계 계산
accident_top10_agg = (
    accident_top10_melted
    .groupby(['region_code', '사고유형'])['사고건수']
    .sum()
    .reset_index()
)

# 시각화
# 스택형 바 차트 시각화
plt.figure(figsize=(10, 6))

sns.set_theme(style="whitegrid")
sns.barplot(
    x='region_code',
    y='사고건수',
    hue='사고유형',
    data=accident_top10_agg,
    estimator=sum,
    ci=None,
    palette='viridis',
    dodge=False # 스택형으로 만들기 위해 False
)

plt.title('Top 10 자치구의 사고 유형별 분포', fontsize=15)
plt.xlabel('자치구', fontsize=12)
plt.ylabel('사고 건수', fontsize=12)
plt.xticks(rotation=45, ha='right') # 자치구 이름이 겹치지 않도록 회전
plt.legend(title='사고 유형')
plt.tight_layout() # 레이아웃 자동 조정
plt.show()

"""# EDA (상관분석 + 시각화)"""

import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import zscore

# 한글 폰트 설정 (colab용)
plt.rc('font', family='NanumGothic')
plt.rcParams['axes.unicode_minus'] = False

# 분석 대상 파생 변수 목록
eda_vars = [
    'license_rate', 'vehicle_rate', 'accident_rate',
    'fatality_rate', 'injury_rate',
    'accident_per_vehicle', 'accident_per_license',
    'accident_per_gdp', 'gdp_per_capita'
]

# 1. 히스토그램 & 박스플롯
for col in eda_vars:
    fig, axes = plt.subplots(1, 2, figsize=(12, 4))

    sns.histplot(merged_df[col], bins=20, kde=True, ax=axes[0], color='skyblue')
    axes[0].set_title(f'{col} - 분포 히스토그램')

    sns.boxplot(x=merged_df[col], ax=axes[1], color='lightcoral')
    axes[1].set_title(f'{col} - 박스플롯 (이상값 확인)')

    plt.tight_layout()
    plt.show()

# 2. 상관관계 히트맵
corr_matrix = merged_df[eda_vars].corr()

plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f", square=True)
plt.title("📌 파생 변수 간 상관관계 히트맵")
plt.tight_layout()
plt.show()

# 3. 주요 상관조합 산점도 (상위 상관계수 조합만)
from itertools import combinations

high_corr_pairs = []
for x, y in combinations(eda_vars, 2):
    corr_val = merged_df[x].corr(merged_df[y])
    if abs(corr_val) > 0.6:
        high_corr_pairs.append((x, y, corr_val))

# 시각화
for x, y, corr_val in high_corr_pairs:
    plt.figure(figsize=(6, 4))
    sns.scatterplot(x=merged_df[x], y=merged_df[y])
    plt.title(f'{x} vs {y} (corr={corr_val:.2f})')
    plt.xlabel(x)
    plt.ylabel(y)
    plt.tight_layout()
    plt.show()

# 4. 이상값 탐지 (z-score 기준)
z_scores = merged_df[eda_vars].apply(zscore)
outlier_flags = (np.abs(z_scores) > 3).sum(axis=1)
outliers = merged_df[outlier_flags > 0]

print(f"이상값 포함 자치구 수: {outliers.shape[0]}")
display(outliers[['region_code'] + eda_vars])

"""# 클러스터링 (K-means)

클리스터링
"""

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import matplotlib.pyplot as plt
import pandas as pd

# 클러스터링 대상 변수
cluster_features = [
    'license_rate', 'vehicle_rate', 'accident_rate',
    'fatality_rate', 'accident_per_license',
    'accident_per_vehicle', 'accident_per_gdp', 'gdp_per_capita'
]

# 1. 결측치 제거 및 지역코드 포함
cluster_df = merged_df[['region_code'] + cluster_features].dropna()

# 2. 표준화
scaler = StandardScaler()
X_scaled = scaler.fit_transform(cluster_df[cluster_features])

# 3. 최적 클러스터 수 탐색 (2~8 범위)
silhouette_scores = {}
for k in range(2, 9):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    labels = kmeans.fit_predict(X_scaled)
    score = silhouette_score(X_scaled, labels)
    silhouette_scores[k] = score

# 4. 최적 K 선택
best_k = max(silhouette_scores, key=silhouette_scores.get)
print(f"▶ 최적 K: {best_k}, Silhouette Score: {silhouette_scores[best_k]:.3f}")

# 5. 최종 모델 학습 및 클러스터 할당
final_kmeans = KMeans(n_clusters=best_k, random_state=42, n_init=10)
cluster_labels = final_kmeans.fit_predict(X_scaled)
cluster_df['cluster'] = cluster_labels

# 6. 병합하여 활용 가능하게 만듦
merged_df = merged_df.merge(cluster_df[['region_code', 'cluster']], on='region_code', how='left')

# 7. 클러스터별 평균값 확인
cluster_profile = (
    cluster_df
    .groupby('cluster')[cluster_features]
    .mean()
    .round(4)
)

# 결과 출력
print("▶ 클러스터 프로파일")
display(cluster_profile)

"""클러스터별 주요 파생지표 분포 시각화 (Boxplot)"""

import matplotlib.pyplot as plt
import seaborn as sns

# 사용할 파생 변수 목록
features = [
    'license_rate', 'vehicle_rate', 'accident_rate',
    'fatality_rate', 'injury_rate',
    'accident_per_vehicle', 'accident_per_license',
    'accident_per_gdp', 'gdp_per_capita'
]

# 시각화 스타일 설정
sns.set(style="whitegrid")
plt.figure(figsize=(16, 18))

# 피처별 Boxplot 반복 생성
for i, feature in enumerate(features, 1):
    plt.subplot(4, 3, i)
    sns.boxplot(x='cluster', y=feature, data=merged_df, palette='Set2')
    plt.title(f'클러스터별 {feature}', fontsize=12)
    plt.xlabel('Cluster', fontsize=10)
    plt.ylabel(feature, fontsize=10)

plt.tight_layout()
plt.show()

"""# 분류 모델링

- 자치구 데이터를 기반으로 “고사고 위험지역(Cluster 0)”을 분류하는 모델

데이터 준비 & 전처리
"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# 사용 변수 정의
features = [
    'license_rate', 'vehicle_rate', 'accident_rate',
    'fatality_rate', 'injury_rate',
    'accident_per_vehicle', 'accident_per_license',
    'accident_per_gdp', 'gdp_per_capita'
]

X = merged_df[features]
y = merged_df['cluster']

# 학습/테스트 데이터 분리
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# 정규화
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""Random Forest 모델 학습"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score

# 모델 훈련
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train_scaled, y_train)

# 예측 및 평가
y_pred = rf.predict(X_test_scaled)
print("🎯 Random Forest 성능 평가")
print(classification_report(y_test, y_pred))
print("ROC AUC Score:", roc_auc_score(y_test, rf.predict_proba(X_test_scaled)[:,1]))

"""XGBoost 모델 학습"""

import xgboost as xgb

xgb_clf = xgb.XGBClassifier(
    n_estimators=100,
    learning_rate=0.1,
    max_depth=3,
    random_state=42,
    use_label_encoder=False,
    eval_metric='logloss'
)
xgb_clf.fit(X_train_scaled, y_train)

# 예측 및 평가
y_pred_xgb = xgb_clf.predict(X_test_scaled)
print("⚡ XGBoost 성능 평가")
print(classification_report(y_test, y_pred_xgb))
print("ROC AUC Score:", roc_auc_score(y_test, xgb_clf.predict_proba(X_test_scaled)[:,1]))

"""변수 중요도 시각화"""

importances = pd.Series(rf.feature_importances_, index=features)
importances.sort_values(ascending=True).plot(kind='barh', figsize=(8, 6))
plt.title("Random Forest Feature Importances")
plt.tight_layout()
plt.show()

"""# 가설 검증, 시각화"""

# 시각화 스타일 설정
sns.set_theme(style="whitegrid")
plt.rcParams['font.family'] = 'NanumGothic'
plt.rcParams['axes.unicode_minus'] = False

"""1. 가설 1: 면허율이 높을수록 사고율이 낮다

"""

# 1. 가설 1: 면허율이 높을수록 사고율이 낮다
plt.figure(figsize=(6.5, 5))
sns.regplot(
    x='license_rate',
    y='accident_rate',
    data=merged_df,
    scatter_kws={'s': 60, 'alpha': 0.7},
    line_kws={'color': 'red', 'linewidth': 2}
)
plt.title('면허율과 사고율의 관계', fontsize=14)
plt.xlabel('면허율 (License Rate)', fontsize=12)
plt.ylabel('사고율 (Accident Rate)', fontsize=12)
plt.tight_layout()
plt.show()

"""가설 1: 면허율 외에 다른 운전 관련 지표와의 상관관계도 함께 시각화 (heatmap)"""

# 가설 1 관련 heatmap
hypo1_cols = [
    'license_rate',
    'accident_rate',
    'accident_per_license',
    'accident_per_vehicle',
    'fatality_rate',
    'injury_rate'
]
plt.figure(figsize=(8, 6))
sns.heatmap(
    merged_df[hypo1_cols].corr(),
    annot=True, cmap='coolwarm', fmt=".2f",
    linewidths=0.5, square=True
)
plt.title('가설 1 확장 Heatmap: 면허율 관련 상관관계', fontsize=14)
plt.tight_layout()
plt.show()

"""2. 가설 2: 1인당 GRDP가 높을수록 사고율이 낮다

"""

# 2. 가설 2: 1인당 GRDP가 높을수록 사고율이 낮다
plt.figure(figsize=(6.5, 5))
sns.regplot(
    x='gdp_per_capita',
    y='accident_rate',
    data=merged_df,
    scatter_kws={'s': 60, 'alpha': 0.7},
    line_kws={'color': 'green', 'linewidth': 2}
)
plt.title('1인당 GRDP와 사고율의 관계', fontsize=14)
plt.xlabel('1인당 GRDP (천원)', fontsize=12)
plt.ylabel('사고율 (Accident Rate)', fontsize=12)
plt.tight_layout()
plt.show()

"""가설2: 경제력(GDP)과 사고 지표 전반의 상관관계 분석 (heatmap)"""

# 가설 2 관련 heatmap
hypo2_cols = [
    'gdp_per_capita',
    'total_gdp',
    'accident_rate',
    'accident_per_gdp',
    'fatality_rate',
    'injury_rate'
]
plt.figure(figsize=(8, 6))
sns.heatmap(
    merged_df[hypo2_cols].corr(),
    annot=True, cmap='YlGnBu', fmt=".2f",
    linewidths=0.5, square=True
)
plt.title('가설 2 확장 Heatmap: GRDP 관련 상관관계', fontsize=14)
plt.tight_layout()
plt.show()

"""3. 가설 3: 클러스터별 차량당 사고율 차이 존재"""

# 3. 가설 3: 클러스터별 차량당 사고율 차이 존재
plt.figure(figsize=(7, 5))
sns.boxplot(
    x='cluster',
    y='accident_per_vehicle',
    data=cluster_df,
    palette='Set2',
    showmeans=True,
    meanprops={"marker":"o", "markerfacecolor":"black", "markeredgecolor":"black"}
)
plt.title('클러스터별 차량당 사고율 분포', fontsize=14)
plt.xlabel('클러스터', fontsize=12)
plt.ylabel('차량당 사고율', fontsize=12)
plt.tight_layout()
plt.show()

"""클러스터 내 주요 지표 간의 상호작용 확인 (heatmap)"""

# 가설 3 관련 heatmap
hypo3_cols = [
    'vehicle_rate',
    'accident_per_vehicle',
    'accident_rate',
    'license_rate',
    'fatality_rate',
    'cluster'
]
# cluster가 숫자이므로 포함해도 상관 없음
plt.figure(figsize=(8, 6))
sns.heatmap(
    cluster_df[hypo3_cols].corr(),
    annot=True, cmap='PuBuGn', fmt=".2f",
    linewidths=0.5, square=True
)
plt.title('가설 3 확장 Heatmap: 차량당 사고율 중심 상관관계', fontsize=14)
plt.tight_layout()
plt.show()

